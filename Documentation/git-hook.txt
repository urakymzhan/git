git-hook(1)
===========

NAME
----
git-hook - run git hooks

SYNOPSIS
--------
[verse]
'git hook' run [--to-stdin=<path>] [--ignore-missing] [(-j|--jobs) <n>]
	<hook-name> [-- <hook-args>]
'git hook' list <hook-name>

DESCRIPTION
-----------

This command is an interface to git hooks (see linkgit:githooks[5]).
Currently it only provides a convenience wrapper for running hooks for
use by git itself. In the future it might gain other functionality.

It's possible to use this command to refer to hooks which are not native to Git,
for example if a wrapper around Git wishes to expose hooks into its own
operation in a way which is already familiar to Git users. However, wrappers
invoking such hooks should be careful to name their hook events something which
Git is unlikely to use for a native hook later on. For example, Git is much less
likely to create a `mytool-validate-commit` hook than it is to create a
`validate-commit` hook.

This command parses the default configuration files for sets of configs like
so:

  [hook "linter"]
    event = pre-commit
    command = ~/bin/linter --cpp20

In this example, `[hook "linter"]` represents one script - `~/bin/linter
--cpp20` - which can be shared by many repos, and even by many hook events, if
appropriate.

To add an unrelated hook which runs on a different event, for example a
spell-checker for your commit messages, you would write a configuration like so:

  [hook "linter"]
    event = pre-commit
    command = ~/bin/linter --cpp20
  [hook "spellcheck"]
    event = commit-msg
    command = ~/bin/spellchecker

With this config, when you run 'git commit', first `~/bin/linter --cpp20` will
have a chance to check your files to be committed (during the `pre-commit` hook
event`), and then `~/bin/spellchecker` will have a chance to check your commit
message (during the `commit-msg` hook event).

Commands are run in the order Git encounters their associated
`hook.<name>.event` configs during the configuration parse (see
linkgit:git-config[1]). Although multiple `hook.linter.event` configs can be
added, only one `hook.linter.command` event is valid - Git uses "last-one-wins"
to determine which command to run.

So if you wanted your linter to run when you commit as well as when you push,
you would configure it like so:

  [hook "linter"]
    event = pre-commit
    event = pre-push
    command = ~/bin/linter --cpp20

With this config, `~/bin/linter --cpp20` would be run by Git before a commit is
generated (during `pre-commit`) as well as before a push is performed (during
`pre-push`).

And if you wanted to run your linter as well as a secret-leak detector during
only the "pre-commit" hook event, you would configure it instead like so:

  [hook "linter"]
    event = pre-commit
    command = ~/bin/linter --cpp20
  [hook "no-leaks"]
    event = pre-commit
    command = ~/bin/leak-detector

With this config, before a commit is generated (during `pre-commit`), Git would
first start `~/bin/linter --cpp20` and second start `~/bin/leak-detector`. It
would evaluate the output of each when deciding whether to proceed with the
commit.

For a full list of hook events which you can set your `hook.<name>.event` to,
and how hooks are invoked during those events, see linkgit:githooks[5].

Git will ignore any `hook.<name>.event` that specifies an event it doesn't
recognize. This is intended so that tools which wrap Git can use the hook
infrastructure to run their own hooks; see <<WRAPPERS>> for more guidance.

In general, when instructions suggest adding a script to
`.git/hooks/<hook-event>`, you can specify it in the config instead by running:

----
git config hook.<some-name>.command <path-to-script>
git config --add hook.<some-name>.event <hook-event>
----

This way you can share the script between multiple repos. That is, `cp
~/my-script.sh ~/project/.git/hooks/pre-commit` would become:

----
git config hook.my-script.command ~/my-script.sh
git config --add hook.my-script.event pre-commit
----

SUBCOMMANDS
-----------

run::
	Runs hooks configured for `<hook-name>`, in the order they are
	discovered during the config parse.
+
Any positional arguments to the hook should be passed after an
optional `--` (or `--end-of-options`, see linkgit:gitcli[7]). The
arguments (if any) differ by hook name, see linkgit:githooks[5] for
what those are.

list::
	Print a list of hooks which will be run on `<hook-name>` event. If no
	hooks are configured for that event, print nothing and return 1.

OPTIONS
-------

--to-stdin::
	For "run"; Specify a file which will be streamed into the
	hook's stdin. The hook will receive the entire file from
	beginning to EOF.

--ignore-missing::
	Ignore any missing hook by quietly returning zero. Used for
	tools that want to do a blind one-shot run of a hook that may
	or may not be present.

-j::
--jobs::
	Only valid for `run`.
+
Specify how many hooks to run simultaneously. If this flag is not specified,
uses the value of the `hook.jobs` config, see linkgit:git-config[1]. If the
config is not specified, uses the number of CPUs on the current system. Some
hooks may be ineligible for parallelization: for example, 'commit-msg' intends
hooks modify the commit message body and cannot be parallelized.

[[WRAPPERS]]
WRAPPERS
--------

`git hook run` has been designed to make it easy for tools which wrap Git to
configure and execute hooks using the Git hook infrastructure. It is possible to
provide arguments, environment variables (TODO this is missing from reroll TODO),
and stdin via the command line, as well as specifying parallel or series
execution if the user has provided multiple hooks.

Assuming your wrapper wants to support a hook named "mywrapper-start-tests", you
can have your users specify their hooks like so:

  [hook "setup-test-dashboard"]
    event = mywrapper-start-tests
    command = ~/mywrapper/setup-dashboard.py --tap

Then, in your 'mywrapper' tool, you can invoke any users' configured hooks by
running:

----
git hook run mywrapper-start-tests \
  # providing something to stdin
  --stdin some-tempfile-123 \
  # setting an env var (TODO THIS IS MISSING TODO)
  --env MYWRAPPER_EXECUTION_MODE=foo \
  # execute hooks in serial
  --jobs 1 \
  # plus some arguments of your own...
  -- \
  --testname bar \
  baz
----

Take care to name your wrapper's hook events in a way which is unlikely to
overlap with Git's native hooks (see linkgit:githooks[5]) - a hook event named
`mywrappertool-validate-commit` is much less likely to be added to native Git
than a hook event named `validate-commit`. If Git begins to use a hook event
named the same thing as your wrapper hook, it may invoke your users' hooks in
unintended and unsupported ways.

CONFIGURATION
-------------
include::config/hook.txt[]

SEE ALSO
--------
linkgit:githooks[5]

GIT
---
Part of the linkgit:git[1] suite
